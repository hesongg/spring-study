### 스프링 DB - 데이터 접근 핵심 원리

#### Reference) 
	* 스프링 DB 1편 - 데이터 접근 핵심 원리 (인프런 김영한님 강의 학습한 내용 정리)

#### 작성 코드
- https://github.com/hesongg/Spring-DB-JDBC
	
<br>


### 트랜잭션 이해


<br>

#### 트랜잭션 - 개념 이해

- 트랜잭션 ACID
	- 트랜잭션은 ACID(http://en.wikipedia.org/wiki/ACID)라 하는 원자성(Atomicity), 일관성 (Consistency), 격리성(Isolation), 지속성(Durability)을 보장해야 한다.
	
	- 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야한다.
	- 일관성: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
	- 격리성: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 
		- 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
	- 지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

- 트랜잭션은 원자성, 일관성, 지속성을 보장한다. 문제는 격리성인데 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 한다. 
	- 이렇게 하면 동시 처리 성능이 매우 나빠진다. 
	- 이런 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다. 
	
- 트랜잭션 격리 수준 - ```Isolation level```
	- READ UNCOMMITED(커밋되지 않은 읽기)
	- READ COMMITTED(커밋된 읽기)
	- REPEATABLE READ(반복 가능한 읽기)
	- SERIALIZABLE(직렬화 가능)

- 일반적으로 많이 사용하는 READ COMMITTED(커밋된 읽기) 트랜잭션 격리 수준을 기준으로 설명

<br>

#### 데이터베이스 연결 구조와 DB 세션

- 데이터베이스 연결 구조
	- 사용자는 웹 애플리케이션 서버(WAS)나 DB 접근 툴 같은 클라이언트를 사용해서 데이터베이스 서버에 접근할 수 있다. 
	- 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺게 된다. 
	- 이때 데이터베이스 서버는 내부에 세션이라는 것을 만든다. 그리고 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다.
	- 쉽게 이야기해서 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행한다.
	- 세션은 트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료한다. 그리고 이후에 새로운 트랜잭션을 다시 시작할 수 있다.
	- 사용자가 커넥션을 닫거나, 또는 DBA(DB 관리자)가 세션을 강제로 종료하면 세션은 종료된다.
	
	- 커넥션 풀이 10개의 커넥션을 생성하면, 세션도 10개 만들어진다.
	
<br>

#### 트랜잭션 - DB 예제1 - 개념 이해	

- 트랜잭션 사용법
	- 데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영하려면 커밋 명령어인 commit 을 호출하고,
		결과를 반영하고 싶지 않으면 롤백 명령어인 rollback 을 호출하면 된다.
	
	- 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자) 에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.

<br>

#### 트랜잭션 - DB 예제2 - 자동 커밋, 수동 커밋

- 자동 커밋
	- 트랜잭션을 사용하려면 먼저 자동 커밋과 수동 커밋을 이해해야 한다.
	- 자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다. 따라서 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있다. 
	- 하지만 쿼리를 하나하나 실행할 때 마다 자동으로 커밋이 되어버리기 때문에 우리가 원하는 트랜잭션 기능을 제대로 사용할 수 없다.

	- H2에서 자동 커밋 설정 테스트
		```sql
		set autocommit true; //자동 커밋 모드 설정
		```

- 수동 커밋 설정
	- H2에서 수동 커밋 설정 테스트
		```sql
		set autocommit false; //자동 커밋 모드 설정
		```
	
	- 보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 
		```트랜잭션을 시작```한다고 표현할 수 있다.
	
	- 수동 커밋 설정을 하면 이후에 꼭 ```commit``` , ```rollback``` 을 호출해야 한다.

<br>

#### DB 락 - 개념 이해

- 세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 
	세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다. 
	
	- 바로 트랜잭션의 원자성이 깨지는 것이다. 
	- 여기에 더해서 세션1이 중간에 롤백을 하게 되면 세션2는 잘못된 데이터를 수정하는 문제가 발생한다.
	- 이런 문제를 방지하려면, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다

	
<br>


#### DB 락 - 조회

- 일반적인 조회는 락을 사용하지 않는다
	- 데이터베이스마다 다르지만, 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 데이터를 조회할 수 있다.
	- 예를 들어서 세션1이 락을 획득하고 데이터를 변경하고 있어도, 세션2에서 데이터를 조회는 할 수 있다.
	- 물론 세션2에서 조회가 아니라 데이터를 변경하려면 락이 필요하기 때문에 락이 돌아올 때 까지 대기해야	한다

- 조회와 락
	- 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다. 이럴 때는 ```select for update``` 구문을 사용하면 된다.
	- 이렇게 하면 세션1이 조회 시점에 락을 가져가버리기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다.
	- 물론 이 경우도 트랜잭션을 커밋하면 락을 반납한다.

<br>

#### 트랜잭션 - 적용1

- 먼저 트랜잭션 없이 단순하게 계좌이체 비즈니스 로직만 구현
	- 트랜잭션이 없는 경우 작업 실패 시 발생하는 문제를 코드로 구현 - 소스 참고
	
<br>

#### 트랜잭션 - 적용2

- DB 트랜잭션을 사용해서 앞서 발생한 문제점을 해결해보자.
- 애플리케이션에서 트랜잭션을 어떤 계층에 걸어야 할까? 쉽게 이야기해서 트랜잭션을 어디에서 시작하고, 어디에서 커밋해야할까?

<br>

- 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다. 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다.
- 그런데 트랜잭션을 시작하려면 커넥션이 필요하다. 결국 서비스 계층에서 커넥션을 만들고, 트랜잭션 커밋 이후에 커넥션을 종료해야 한다.
- 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야한다. 그래야 같은 세션을 사용할 수 있다.

- 애플리케이션에서 같은 커넥션을 유지하려면 어떻게 해야할까? 
	- 가장 단순한 방법은 커넥션을 파라미터로 전달해서 같은 커넥션이 사용되도록 유지하는 것
	
- 1. 커넥션 유지가 필요한 두 메서드는 파라미터로 넘어온 커넥션을 사용해야 한다. 따라서 con = getConnection() 코드가 있으면 안된다.
- 2. 커넥션 유지가 필요한 두 메서드는 리포지토리에서 커넥션을 닫으면 안된다. 커넥션을 전달 받은 리포지토리 뿐만 아니라 이후에도 커넥션을 계속 이어서 사용하기 때문이다. 
	- 이후 서비스 로직이 끝날 때트랜잭션을 종료하고 닫아야 한다.

<br>

- 트랜잭션을 시작하려면 커넥션이 필요하다.
	```java
	con.setAutoCommit(false); //트랜잭션 시작
	```
	
	- 트랜잭션을 시작하려면 자동 커밋 모드를 꺼야한다. 이렇게 하면 커넥션을 통해 세션에 set
	
	- ```autocommit false``` 가 전달되고, 이후부터는 수동 커밋 모드로 동작한다. 
		- 이렇게 자동 커밋 모드를 수동 커밋 모드로 변경하는 것을 트랜잭션을 시작한다고 보통 표현한다.

- ```con.commit();``` : 성공시 커밋
	- 비즈니스 로직이 정상 수행되면 트랜잭션을 커밋한다.

- ```con.rollback();``` : 실패시 롤백
	- ```catch(Ex){..}``` 를 사용해서 비즈니스 로직 수행 도중에 예외가 발생하면 트랜잭션을 롤백한다.
	
- ```release(con);```
	- ```finally {..}``` 를 사용해서 커넥션을 모두 사용하고 나면 안전하게 종료한다. 
	- 그런데 커넥션 풀을 사용하면 ```con.close()``` 를 호출 했을 때 커넥션이 종료되는 것이 아니라 풀에 반납된다. 
	- 현재 수동 커밋 모드로 동작하기 때문에 풀에 돌려주기 전에 기본 값인 자동 커밋 모드로 변경하는 것이 안전하다.
	
- 트랜잭션 덕분에 계좌이체가 실패할 때 롤백을 수행해서 모든 데이터를 정상적으로 초기화 할 수 있게 되었다. 

<br>

- 남은 문제
	- 애플리케이션에서 DB 트랜잭션을 적용하려면 서비스 계층이 매우 지저분해지고, 생각보다 매우 복잡한 코드를 요구한다. 
	- 추가로 커넥션을 유지하도록 코드를 변경하는 것도 쉬운 일은 아니다. 다음 시간에는 스프링을 사용해서 이런 문제들을 하나씩 해결해본다.
