### 스프링 DB - 데이터 접근 활용 기술

#### Reference) 
	* 스프링 DB 2편 - 데이터 접근 활용 기술 (인프런 김영한님 강의 학습한 내용 정리)

#### 작성 코드
- https://github.com/hesongg/Spring-DB-Transaction
	
<br>


### 스프링 트랜잭션 전파2 - 활용

<br>

#### 트랜잭션 전파 활용1 - 예제 프로젝트 시작

- 비즈니스 요구사항
	- 회원을 등록하고 조회한다.
	- 회원에 대한 변경 이력을 추적할 수 있도록 회원 데이터가 변경될 때 변경 이력을 DB LOG 테이블에 남겨야 한다.
		- 여기서는 예제를 단순화 하기 위해 회원 등록시에만 DB LOG 테이블에 남긴다.
	
<br>

- 구현 코드 및 테스트 코드는는 ```propagation``` 패키지에..

- 참고
	- JPA의 구현체인 하이버네이트가 테이블을 자동으로 생성해준다.
	- 메모리 DB이기 때문에 모든 테스트가 완료된 이후에 DB는 사라진다.
	- 여기서는 각각의 테스트가 완료된 시점에 데이터를 삭제하지 않는다. 
		- 따라서 username 은 테스트별로 각각 다르게 설정해야 한다. 
		- 그렇지 않으면 다음 테스트에 영향을 준다. (모든 테스트가 완료되어야 DB가	사라진다.)
		
<br>

- JPA와 데이터 변경
	- JPA를 통한 모든 데이터 변경(등록, 수정, 삭제)에는 트랜잭션이 필요하다. (조회는 트랜잭션 없이 가능하다.)
		- 현재 코드에서 서비스 계층에 트랜잭션이 없기 때문에 리포지토리에 트랜잭션이 있다.

<br>

#### 트랜잭션 전파 활용2 - 커밋, 롤백

- 서비스 계층에 트랜잭션이 없을 때 - 커밋

	- 상황
		- 서비스 계층에 트랜잭션이 없다.
		- 회원, 로그 리포지토리가 각각 트랜잭션을 가지고 있다.
		- 회원, 로그 리포지토리 둘다 커밋에 성공한다.

	<br>

- 서비스 계층에 트랜잭션이 없을 때 - 롤백

	- 상황
		- 서비스 계층에 트랜잭션이 없다.
		- 회원, 로그 리포지토리가 각각 트랜잭션을 가지고 있다.
		- 회원 리포지토리는 정상 동작하지만 로그 리포지토리에서 예외가 발생한다.

	- 사용자 이름에 로그예외 라는 단어가 포함되어 있으면 LogRepository 에서 런타임 예외가 발생한다.
		- 트랜잭션 AOP는 해당 런타임 예외를 확인하고 롤백 처리한다.

	- ```Log``` 서비스만 롤백된다.

	- 참고
		- 트랜잭션 AOP도 결국 내부에서는 트랜잭션 매니저를 사용하게 된다.
		
		- 이 경우 회원은 저장되지만, 회원 이력 로그는 롤백된다. 
			- 따라서 데이터 정합성에 문제가 발생할 수 있다.
		
		- 둘을 하나의 트랜잭션으로 묶어서 처리해보자.

<br>

#### 트랜잭션 전파 활용3 - 단일 트랜잭션

- 트랜잭션 하나만 사용하기
	- 회원 리포지토리와 로그 리포지토리를 하나의 트랜잭션으로 묶는 가장 간단한 방법은 이 둘을 호출하는 회원 서비스에만 트랜잭션을 사용하는 것이다.

<br>

- ```MemberRepository``` , ```LogRepository``` 의 ```@Transactional``` 코드를 제거하자.
	- 그리고 ```MemberService``` 에만 ```@Transactional``` 코드를 추가

	- 이렇게 하면 ```MemberService``` 를 시작할 때 부터 종료할 때 까지의 모든 로직을 하나의 트랜잭션으로 묶을 수 있다.
		- 물론 ```MemberService``` 가 ```MemberRepository``` , ```LogRepository``` 를 호출하므로 
			이 로직들은 같은 트랜잭션을 사용한다.
	
	- ```MemberService``` 만 트랜잭션을 처리하기 때문에 앞서 배운 논리 트랜잭션, 물리 트랜잭션, 외부 트랜잭션,
		내부 트랜잭션, ```rollbackOnly``` , 신규 트랜잭션, 트랜잭션 전파와 같은 복잡한 것을 고민할 필요가 없다.
		- 아주 단순하고 깔끔하게 트랜잭션을 묶을 수 있다

<br>

- ```@Transactional``` 이 ```MemberService``` 에만 붙어있기 때문에 여기에만 트랜잭션 AOP가 적용된다.
	- ```MemberRepository``` , ```LogRepository``` 는 트랜잭션 AOP가 적용되지 않는다.
	- ```MemberService``` 의 시작부터 끝까지, 관련 로직은 해당 트랜잭션이 생성한 커넥션을 사용하게 된다.
	- ```MemberService``` 가 호출하는 ```MemberRepository``` , ```LogRepository``` 도 같은 커넥션을 사용하면서 자연스럽게 트랜잭션 범위에 포함된다.

- 참고
	- 같은 쓰레드를 사용하면 트랜잭션 동기화 매니저는 같은 커넥션을 반환한다.

<br>

- 각각 트랜잭션이 필요한 상황
	- 클라이언트 A는 ```MemberService``` 부터 ```MemberRepository``` , ```LogRepository``` 를 모두 하나의 트랜잭션으로 묶고 싶다.
	- 클라이언트 B는 ```MemberRepository``` 만 호출하고 여기에만 트랜잭션을 사용하고 싶다.
	- 클라이언트 C는 ```LogRepository``` 만 호출하고 여기에만 트랜잭션을 사용하고 싶다.

	- 클라이언트 A만 생각하면 MemberService 에 트랜잭션 코드를 남기고, ```MemberRepository``` ,
		```LogRepository``` 의 트랜잭션 코드를 제거하면 앞서 배운 것 처럼 깔끔하게 하나의 트랜잭션을 적용할 수 있다.
		- 하지만 이렇게 되면 클라이언트 B, C가 호출하는 ```MemberRepository``` , ```LogRepository``` 에는 트랜잭션을 적용할 수 없다

	- 트랜잭션 전파 없이 이런 문제를 해결하려면 아마도 트랜잭션이 있는 메서드와 트랜잭션이 없는 메서드를 각각 만들어야 할 것이다.
		- 이런 문제를 해결하기 위해 트랜잭션 전파가 필요한 것

<br>

#### 트랜잭션 전파 활용4 - 전파 커밋

- 스프링은 ```@Transactional``` 이 적용되어 있으면 기본으로 ```REQUIRED``` 라는 전파 옵션을 사용한다.
	- 이 옵션은 기존 트랜잭션이 없으면 트랜잭션을 생성하고, 기존 트랜잭션이 있으면 기존 트랜잭션에 참여한다. 
	- 참여한다는 뜻은 해당 트랜잭션을 그대로 따른다는 뜻이고, 동시에 같은 동기화 커넥션을 사용한다는 뜻이다

<br>

- 모든 논리 트랜잭션이 정상 커밋되는 경우 테스트 수행

	![image](https://user-images.githubusercontent.com/77953474/187148113-6d1f9d44-0a7a-4de8-bbf1-31fbb7730601.png)


<br>

#### 트랜잭션 전파 활용5 - 전파 롤백

- 로그 리포지토리에서 예외가 발생해서 전체 트랜잭션이 롤백되는 경우를 알아보자.

- 테스트에서 ```로그예외``` 라고 넘겼기 때문에 ```LogRepository``` 에서 런타임 예외가 발생한다.
	
<br>

- 흐름
	
	![image](https://user-images.githubusercontent.com/77953474/187148239-72f9c97b-4ca1-4ef9-9a7d-521fb2503c9d.png)

	
	- 클라이언트A가 ```MemberService``` 를 호출하면서 트랜잭션 AOP가 호출된다.
		- 여기서 신규 트랜잭션이 생성되고, 물리 트랜잭션도 시작한다.
	
	- ```MemberRepository``` 를 호출하면서 트랜잭션 AOP가 호출된다.
		- 이미 트랜잭션이 있으므로 기존 트랜잭션에 참여한다.
		
	- ```MemberRepository``` 의 로직 호출이 끝나고 정상 응답하면 트랜잭션 AOP가 호출된다.
		- 트랜잭션 AOP는 정상 응답이므로 트랜잭션 매니저에 커밋을 요청한다. 
		- 이 경우 신규 트랜잭션이 아니므로 실제 커밋을 호출하지 않는다.
		
	- ```LogRepository``` 를 호출하면서 트랜잭션 AOP가 호출된다.
		- 이미 트랜잭션이 있으므로 기존 트랜잭션에 참여한다.
		
	- ```LogRepository``` 로직에서 런타임 예외가 발생한다. 예외를 던지면 트랜잭션 AOP가 해당 예외를 받게 된다.
		- 트랜잭션 AOP는 런타임 예외가 발생했으므로 트랜잭션 매니저에 롤백을 요청한다. 
			- 이 경우 신규	트랜잭션이 아니므로 물리 롤백을 호출하지는 않는다. 대신에 ```rollbackOnly``` 를 설정한다.
		- ```LogRepository``` 가 예외를 던졌기 때문에 트랜잭션 AOP도 해당 예외를 그대로 밖으로 던진다.
		
	- ```MemberService``` 에서도 런타임 예외를 받게 되는데, 여기 로직에서는 해당 런타임 예외를 처리하지 않고 밖으로 던진다.
		- 트랜잭션 AOP는 런타임 예외가 발생했으므로 트랜잭션 매니저에 롤백을 요청한다. 
			- 이 경우 신규	트랜잭션이므로 물리 롤백을 호출한다.
		
		- 참고로 이 경우 어차피 롤백이 되었기 때문에, ```rollbackOnly``` 설정은 참고하지 않는다.
		- ```MemberService``` 가 예외를 던졌기 때문에 트랜잭션 AOP도 해당 예외를 그대로 밖으로 던진다.
	
	- 클라이언트A는 ```LogRepository``` 부터 넘어온 런타임 예외를 받게 된다.

<br>

- 정리
	- 회원과 회원 이력 로그를 처리하는 부분을 하나의 트랜잭션으로 묶은 덕분에 
		문제가 발생했을 때 회원과 회원 이력 로그가 모두 함께 롤백된다. 
		- 따라서 데이터 정합성에 문제가 발생하지 않는다.

<br>

#### 트랜잭션 전파 활용6 - 복구 REQUIRED

- 비즈니스 요구사항이 변경되었다.
	- 회원 가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 유지되어야 한다.

- 단순하게 생각해보면 ```LogRepository``` 에서 예외가 발생하면 그것을 ```MemberService``` 에서 예외를 잡아서 처리하면 될 것 같다.
	- 이 방법이 왜 실패하는지 예제를 통해서 알아보자. 참고로 실무에서 많은 개발자가 이 방법을 사용해서 실패한다.

<br>

- 내부 트랜잭션에서 ```rollbackOnly``` 를 설정하기 때문에 결과적으로 정상 흐름 처리를 해서 
	외부 트랜잭션에서 커밋을 호출해도 물리 트랜잭션은 롤백된다.

	- 그리고 ```UnexpectedRollbackException``` 이 던져진다.

<br>

- 전체 흐름을 좀 더 자세히 알아보자.
	
	![image](https://user-images.githubusercontent.com/77953474/187148357-97c53e4f-117b-4fe2-b9b1-0d5de69b091c.png)

	
	- ```LogRepository``` 에서 예외가 발생한다. 
		- 예외를 던지면 ```LogRepository``` 의 트랜잭션 AOP가 해당 예외를 받는다.
	
	- 신규 트랜잭션이 아니므로 물리 트랜잭션을 롤백하지는 않고, 트랜잭션 동기화 매니저에 ```rollbackOnly``` 를 표시한다.
	
	- 이후 트랜잭션 AOP는 전달 받은 예외를 밖으로 던진다.
	
	- 예외가 ```MemberService``` 에 던져지고, ```MemberService``` 는 해당 예외를 복구한다. 
		- 그리고 정상적으로 리턴한다.
	
	- 정상 흐름이 되었으므로 ```MemberService``` 의 트랜잭션 AOP는 커밋을 호출한다.
	
	- 커밋을 호출할 때 신규 트랜잭션이므로 실제 물리 트랜잭션을 커밋해야 한다. 이때 ```rollbackOnly``` 를 체크한다.
	
	- ```rollbackOnly``` 가 체크 되어 있으므로 물리 트랜잭션을 롤백한다.
	
	- 트랜잭션 매니저는 ```UnexpectedRollbackException``` 예외를 던진다.
	
	- 트랜잭션 AOP도 전달받은 ```UnexpectedRollbackException``` 을 클라이언트에 던진다

<br>

- 정리
	- 논리 트랜잭션 중 하나라도 롤백되면 전체 트랜잭션은 롤백된다.
	- 내부 트랜잭션이 롤백 되었는데, 외부 트랜잭션이 커밋되면 ```UnexpectedRollbackException``` 예외가 발생한다.

	- ```rollbackOnly``` 상황에서 커밋이 발생하면 ```UnexpectedRollbackException``` 예외가 발생한다.
	
	- 그렇다면 어떻게 해야 다음 요구사항을 만족할 수 있을까?
		- 회원 가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 유지되어야 한다

<br>

#### 트랜잭션 전파 활용7 - 복구 REQUIRES_NEW

- 회원 가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 유지되어야 한다.

- 이 요구사항을 만족하기 위해서 로그와 관련된 물리 트랜잭션을 별도로 분리해보자. 
	- 바로 ```REQUIRES_NEW``` 를 사용하는 것이다

<br>

- ```LogRepository - save()```
	
	```java
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void save(Log logMessage)
	```
	
	- 이렇게 해서 기존 트랜잭션에 참여하는 ```REQUIRED``` 대신에, 항상 신규 트랜잭션을 생성하는 ```REQUIRES_NEW``` 를 적용하자.

- 예외를 복구하는 ```memberService.joinV2()```를 사용한다는 점도 주의하자

<br>

- ```REQUIRES_NEW - 물리 트랜잭션 분리```
	- ```MemberRepository``` 는 ```REQUIRED``` 옵션을 사용한다. 따라서 기존 트랜잭션에 참여한다.
	- ```LogRepository``` 의 트랜잭션 옵션에 ```REQUIRES_NEW``` 를 사용했다.
	- ```REQUIRES_NEW``` 는 항상 새로운 트랜잭션을 만든다. 
		- 따라서 해당 트랜잭션 안에서는 DB 커넥션도 별도로 사용하게 된다.

- ```REQUIRES_NEW - 복구```
	- ```REQUIRES_NEW``` 를 사용하게 되면 물리 트랜잭션 자체가 완전히 분리되어 버린다.
	- 그리고 ```REQUIRES_NEW``` 는 신규 트랜잭션이므로 ```rollbackOnly``` 표시가 되지 않는다. 
		- 그냥 해당 트랜잭션이 물리 롤백되고 끝난다.

<br>

- ```REQUIRES_NEW - 자세히```
	
	![image](https://user-images.githubusercontent.com/77953474/187148471-52d8642f-3364-4db8-8b3d-33fffd26f5fc.png)

	
	- ```LogRepository``` 에서 예외가 발생한다. 예외를 던지면 ```LogRepository``` 의 트랜잭션 AOP가 해당 예외를 받는다.
	
	- ```REQUIRES_NEW``` 를 사용한 신규 트랜잭션이므로 물리 트랜잭션을 롤백한다. 
		- 물리 트랜잭션을 롤백했으므로 ```rollbackOnly``` 를 표시하지 않는다. 
		- 여기서 ```REQUIRES_NEW``` 를 사용한 물리 트랜잭션은 롤백되고 완전히 끝이 나버린다.
		
	- 이후 트랜잭션 AOP는 전달 받은 예외를 밖으로 던진다.
	
	- 예외가 ```MemberService``` 에 던져지고, ```MemberService``` 는 해당 예외를 복구한다. 
		- 그리고 정상적으로 리턴한다.
	
	- 정상 흐름이 되었으므로 ```MemberService``` 의 트랜잭션 AOP는 커밋을 호출한다.
	
	- 커밋을 호출할 때 신규 트랜잭션이므로 실제 물리 트랜잭션을 커밋해야 한다. 
		- 이때 ```rollbackOnly``` 를 체크한다.
	
	- ```rollbackOnly``` 가 없으므로 물리 트랜잭션을 커밋한다.
	
	- 이후 정상 흐름이 반환된다.
	
	- 결과적으로 회원 데이터는 저장되고, 로그 데이터만 롤백 되는 것을 확인할 수 있다.
	
<br>

- 정리
	- 논리 트랜잭션은 하나라도 롤백되면 관련된 물리 트랜잭션은 롤백되어 버린다.
	
	- 이 문제를 해결하려면 ```REQUIRES_NEW``` 를 사용해서 트랜잭션을 분리해야 한다.
	
	- 참고로 예제를 단순화 하기 위해 ```MemberService``` 가 ```MemberRepository``` , ```LogRepository``` 만
		호출하지만 실제로는 더 많은 리포지토리들을 호출하고 그 중에 ```LogRepository``` 만 트랜잭션을 분리한다고 생각해보면 이해하는데 도움이 될 것이다.
	
<br>

- 주의
	- ```REQUIRES_NEW``` 를 사용하면 하나의 HTTP 요청에 동시에 2개의 데이터베이스 커넥션을 사용하게 된다.
	
	- 따라서 성능이 중요한 곳에서는 이런 부분을 주의해서 사용해야 한다.
	
	- ```REQUIRES_NEW``` 를 사용하지 않고 문제를 해결할 수 있는 단순한 방법이 있다면, 그 방법을 선택하는 것이 더 좋다.

		- 예를 들면 다음과 같이 ```REQUIRES_NEW``` 를 사용하지 않고 구조를 변경하는 것이다.
			
			![image](https://user-images.githubusercontent.com/77953474/187148576-454a81b2-96c5-4618-bcfd-882b8a57aff6.png)

			
			- 이렇게 하면 HTTP 요청에 동시에 2개의 커넥션을 사용하지는 않는다. 
			- 순차적으로 사용하고 반환하게 된다.
			- 물론 구조상 ```REQUIRES_NEW``` 를 사용하는 것이 더 깔끔한 경우도 있으므로 각각의 장단점을 이해하고
				적절하게 선택해서 사용하면 된다
