### 스프링 DB - 데이터 접근 활용 기술

#### Reference) 
	* 스프링 DB 2편 - 데이터 접근 활용 기술 (인프런 김영한님 강의 학습한 내용 정리)

#### 작성 코드
- https://github.com/hesongg/Spring-DB-Itemservice
	
<br>


### 데이터 접근 기술 - 테스트


<br>

#### 테스트 - 데이터베이스 연동

- 테스트 케이스는 ```src/test``` 에 있기 때문에, 실행하면 ```src/test``` 에 있는 ```application.properties``` 파일이 우선순위를 가지고 실행된다
	- 테스트 케이스에서도 데이터베이스에 접속할 수 있게 ```test```의 ```application.properties``` 파일에도 datasource 정보 설정 필요
	
- 테스트 코드에 ```@SpringBootTest``` 설정 시 ```@SpringBootApplication``` 를 찾아서 설정으로 사용한다.

<br>

#### 테스트 - 데이터베이스 분리

- 테이블 생성하기
	- ```testcase``` 데이터베이스에도 ```item``` 테이블을 생성
		```sql
		drop table if exists item CASCADE;
		
		create table item
		(
			id bigint generated by default as identity,
			item_name varchar(10),
			price integer,
			quantity integer,
			primary key (id)
		);
		```
	
	- 테스트에서 매우 중요한 원칙은 다음과 같다.
		- 테스트는 다른 테스트와 격리해야 한다.
		- 테스트는 반복해서 실행할 수 있어야 한다.
		
	- 물론 테스트가 끝날 때 마다 추가한 데이터에 ```DELETE SQL``` 을 사용해도 되겠지만, 이 방법도 궁극적인 해결책은 아니다.

<br>

#### 테스트 - 데이터 롤백

- 트랜잭션과 롤백 전략
	- 이때 도움이 되는 것이 바로 트랜잭션이다.
	- 테스트가 끝나고 나서 트랜잭션을 강제로 롤백해버리면 데이터가 깔끔하게 제거된다.
	- 테스트를 하면서 데이터를 이미 저장했는데, 중간에 테스트가 실패해서 롤백을 호출하지 못해도 괜찮다.
	- 트랜잭션을 커밋하지 않았기 때문에 데이터베이스에 해당 데이터가 반영되지 않는다.
	- 이렇게 트랜잭션을 활용하면 테스트가 끝나고 나서 데이터를 깔끔하게 원래 상태로 되돌릴 수 있다.
	
	- 각각의 테스트 실행 직전에 트랜잭션을 시작하고, 각각의 테스트 실행 직후에 트랜잭션을 롤백해야 한다. 
		- 그래야 다음 테스트에 데이터로 인한 영향을 주지 않는다.
		
- 테스트는 각각의 테스트 실행 전 후로 동작하는 ```@BeforeEach``` , ```@AfterEach``` 라는 편리한 기능을 제공

- 테스트에 트랜잭션 관련 코드 추가
	```java
	//트랜잭션 관련 코드
	@Autowired
	PlatformTransactionManager transactionManager;
	TransactionStatus status;
	
	@BeforeEach
	void beforeEach() {
		//트랜잭션 시작
		status = transactionManager.getTransaction(new DefaultTransactionDefinition());
	}
	
	@AfterEach
	void afterEach() {
		//MemoryItemRepository 의 경우 제한적으로 사용
		if (itemRepository instanceof MemoryItemRepository) {
			((MemoryItemRepository) itemRepository).clearStore();
		}
		
		//트랜잭션 롤백
		transactionManager.rollback(status);
	}
	```
	
	- 트랜잭션 관리자는 ```PlatformTransactionManager``` 를 주입 받아서 사용하면 된다. 
		- 참고로 스프링 부트는 자동으로 적절한 트랜잭션 매니저를 스프링 빈으로 등록해준다
		
	- ```@BeforeEach``` : 각각의 테스트 케이스를 실행하기 직전에 호출된다. 따라서 여기서 트랜잭션을 시작하면 된다. 
		- 각각의 테스트를 트랜잭션 범위 안에서 실행할 수 있다.
		- ```transactionManager.getTransaction(new DefaultTransactionDefinition())``` 로 트랜잭션을 시작한다.
	
	- ```@AfterEach``` : 각각의 테스트 케이스가 완료된 직후에 호출된다. 따라서 여기서 트랜잭션을 롤백하면 된다.
		- 데이터를 트랜잭션 실행 전 상태로 복구할 수 있다.
		- ```transactionManager.rollback(status)``` 로 트랜잭션을 롤백
	
<br>

#### 테스트 - @Transactional
	
- 스프링은 테스트 데이터 초기화를 위해 트랜잭션을 적용하고 롤백하는 방식을 ```@Transactional``` 애노테이션 하나로 깔끔하게 해결해준다
	- 이전에 테스트에 트랜잭션과 롤백을 위해 추가했던 코드들을 주석 처리

- 테스트 코드에 스프링이 제공하는 ```@Transactional``` 를 추가
	- ```org.springframework.transaction.annotation.Transactional```
	
- ```@Transactional``` 원리
	- 스프링이 제공하는 ```@Transactional``` 애노테이션은 로직이 성공적으로 수행되면 커밋하도록 동작한다.
	- 그런데 ```@Transactional``` 애노테이션을 테스트에서 사용하면 아주 특별하게 동작한다.
		- ```@Transactional``` 이 테스트에 있으면 스프링은 테스트를 트랜잭션 안에서 실행하고, 테스트가 끝나면 트랜잭션을 자동으로 롤백시켜 버린다.

<br>

- ```@Transactional```이 적용된 테스트 동작 방식
	- 1. 테스트에 ```@Transactional``` 애노테이션이 테스트 메서드나 클래스에 있으면 먼저 트랜잭션을 시작한다.
	
	- 2. 테스트를 로직을 실행한다. 테스트가 끝날 때 까지 모든 로직은 트랜잭션 안에서 수행된다.
		- 트래잭션은 기본적으로 전파되기 때문에, 리포지토리에서 사용하는 ```JdbcTemplate```도 같은 트랜잭션을 사용한다.
	
	- 3. 테스트 실행 중에 ```INSERT SQL```을 사용해서 ```item1``` , ```item2``` , ```item3``` 를 데이터베이스에 저장한다.
		- 물론 테스트가 리포지토리를 호출하고, 리포지토리는 ```JdbcTemplate```을 사용해서 데이터를 저장한다.
	
	- 4. 검증을 위해서 ```SELECT SQL```로 데이터를 조회한다. 
		- 여기서는 앞서 저장한 ```item1``` , ```item2``` , ```item3``` 이 조회되었다.
		- ```SELECT SQL```도 같은 트랜잭션을 사용하기 때문에 저장한 데이터를 조회할 수 있다. 
		- 다른 트랜잭션에서는 해당 데이터를 확인할 수 없다.
		- 여기서 ```assertThat()``` 으로 검증이 모두 끝난다.
	
	- 5. ```@Transactional``` 이 테스트에 있으면 테스트가 끝날때 트랜잭션을 강제로 롤백한다.
	
	- 6. 롤백에 의해 앞서 데이터베이스에 저장한 ```item1``` , ```item2``` , ```item3``` 의 데이터가 제거된다

<br>

- 정리
	- 테스트가 끝난 후 개발자가 직접 데이터를 삭제하지 않아도 되는 편리함을 제공한다.
	- 테스트 실행 중에 데이터를 등록하고 중간에 테스트가 강제로 종료되어도 걱정이 없다. 
	- 이 경우 트랜잭션을 커밋하지 않기 때문에, 데이터는 자동으로 롤백된다. (보통 데이터베이스 커넥션이 끊어지면 자동으로 롤백되어 버린다.)
	- 트랜잭션 범위 안에서 테스트를 진행하기 때문에 동시에 다른 테스트가 진행되어도 서로 영향을 주지 않는	장점이 있다.
	- ```@Transactional``` 덕분에 아주 편리하게 다음 원칙을 지킬수 있게 되었다.
		- 테스트는 다른 테스트와 격리해야 한다.
		- 테스트는 반복해서 실행할 수 있어야 한다.

<br>

- 강제로 커밋하기 - ```@Commit```
	- ```@Transactional``` 을 테스트에서 사용하면 테스트가 끝나면 바로 롤백되기 때문에 테스트 과정에서 저장한	모든 데이터가 사라진다. 
	- 당연히 이렇게 되어야 하지만, 정말 가끔은 데이터베이스에 데이터가 잘	보관되었는지 최종 결과를 눈으로 확인하고 싶을 때도 있다. 
	- 이럴 때는 다음과 같이 ```@Commit``` 을 클래스	또는 메서드에 붙이면 테스트 종료후 롤백 대신 커밋이 호출된다. 
		- 참고로 ```@Rollback(value = false)``` 를 사용해도 된다.
		
<br>

#### 테스트 - 임베디드 모드 DB

- 임베디드 모드
	- H2 데이터베이스는 자바로 개발되어 있고, JVM안에서 메모리 모드로 동작하는 특별한 기능을 제공
	- 그래서 애플리케이션을 실행할 때 H2 데이터베이스도 해당 JVM 메모리에 포함해서 함께 실행할 수 있다.
	- DB를 애플리케이션에 내장해서 함께 실행한다고 해서 임베디드 모드(Embedded mode)라 한다. 
	- 물론 애플리케이션이 종료되면 임베디드 모드로 동작하는 H2 데이터베이스도 함께 종료되고, 데이터도 모두 사라진다. 
		- 쉽게 이야기해서 애플리케이션에서 자바 메모리를 함께 사용하는 라이브러리처럼 동작하는	것이다.
	
- 임베디드 모드 직접 사용
	- ```ItemServiceApplication``` 에 밑의 내용 추가함
		```java
		@Bean
		@Profile("test")
		public DataSource dataSource() {
			log.info("메모리 데이터베이스 초기화");
			DriverManagerDataSource dataSource = new DriverManagerDataSource();
			dataSource.setDriverClassName("org.h2.Driver");
			dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
			dataSource.setUsername("sa");
			dataSource.setPassword("");
			return dataSource;
		}
		```
		
		- ```@Profile("test")```
			- 프로필이 ```test``` 인 경우에만 데이터소스를 스프링 빈으로 등록한다.
			- 테스트 케이스에서만 이 데이터소스를 스프링 빈으로 등록해서 사용하겠다는 뜻이다.
		
		- ```dataSource()```
			- ```jdbc:h2:mem:db``` : 이 부분이 중요하다. 데이터소스를 만들때 이렇게만 적으면 임베디드 모드(메모리	모드)로 동작하는 H2 데이터베이스를 사용할 수 있다.
			- ```DB_CLOSE_DELAY=-1``` : 임베디드 모드에서는 데이터베이스 커넥션 연결이 모두 끊어지면 데이터베이스도 종료되는데, 그것을 방지하는 설정이다.
			- 이 데이터소스를 사용하면 메모리 DB를 사용할 수 있다

<br>

- 테스트를 실행하기 전에 테이블을 먼저 생성해주어야 한다. 수동으로 할 수도 있지만 스프링 부트는 이 문제를 해결할 아주 편리한 기능을 제공해준다.
	- 스프링 부트 - 기본 SQL 스크립트를 사용해서 데이터베이스를 초기화하는 기능
	
	- 메모리 DB는 애플리케이션이 종료될 때 함께 사라지기 때문에, 애플리케이션 실행 시점에 데이터베이스 테이블도 새로 만들어주어야 한다.
	
	- JDBC나 JdbcTemplate를 직접 사용해서 테이블을 생성하는 DDL을 호출해도 되지만, 너무 불편하다.
	
	- 스프링 부트는 SQL 스크립트를 실행해서 애플리케이션 로딩 시점에 데이터베이스를 초기화하는 기능을 제공한다
	
	- 다음 파일을 생성하자.
		- 위치 : ```src/test``` , 파일명 : ```src/test/resources/schema.sql```
			```sql
			drop table if exists item CASCADE;
			
			create table item
			(
				id bigint generated by default as identity,
				item_name varchar(10),
				price integer,
				quantity integer,
				primary key (id)
			);
			```
			
	- 참고
		- SQL 스크립트를 사용해서 데이터베이스를 초기화하는 자세한 방법은 다음 스프링 부트 공식 메뉴얼을 참고
			- https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.datainitialization.using-basic-sql-scripts
<br>

#### 테스트 - 스프링 부트와 임베디드 모드

- 스프링 부트는 개발자에게 정말 많은 편리함을 제공하는데, 임베디드 데이터베이스에 대한 설정도 기본으로 제공
	- 스프링 부트는 데이터베이스에 대한 별다른 설정이 없으면 임베디드 데이터베이스를 사용

- 앞서 직접 설정했던 메모리 DB용 데이터소스를 주석처리 / 테스트에서 데이터베이스에 접근하는 설정 정보도 주석처리

- 이렇게 하면 데이터베이스에 접근하는 모든 설정 정보가 사라지게 된다.
	- 이렇게 별다른 정보가 없으면 스프링 부트는 임베디드 모드로 접근하는 데이터소스( ```DataSource``` )를 만들어서 제공

- 로그를 보면 다음 부분을 확인할 수 있는데 jdbc:h2:mem 뒤에 임의의 데이터베이스 이름이 들어가있다. 
	- 이것은 혹시라도 여러 데이터소스가 사용될 때 같은 데이터베이스를 사용하면서 발생하는 충돌을 방지하기 위해 스프링 부트가 임의의 이름을 부여한 것이다.
	
	- ```conn0: url=jdbc:h2:mem:d8fb3a29-caf7-4b37-9b6c-b0eed9985454```

- 임베디드 데이터베이스 이름을 스프링 부트가 기본으로 제공하는 ```jdbc:h2:mem:testdb``` 로 고정하고 싶으면 ```application.properties``` 에 다음 설정을 추가하면 된다.
	```properties
	spring.datasource.generate-unique-name=false
	```
	
- 참고
	- 임베디드 데이터베이스에 대한 스프링 부트의 더 자세한 설정은 다음 공식 메뉴얼을 참고하자.
	- https://docs.spring.io/spring-boot/docs/current/reference/html/data.html#data.sql.datasource.embedded
