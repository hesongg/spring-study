### 스프링 핵심 원리 - 기본 

#### Reference) 
	* 스프링 핵심 원리 - 기본 (인프런 김영한님 강의 학습한 내용 정리)

#### 작성 코드
https://github.com/hesongg/inflearn-study

#### 의존관계 주입

- 의존관계 주입 방법 종류
	- 생성자 주입
		- 생성자를 통해서 의존 관계를 주입 받는 방법
		- 생성자 호출 시 딱 1번 호출되는 것이 보장됨
		- 불변 / 필수 의존관계에 사용
		- 생성자가 한 개만 있으면 @Autowired 생략 가능
		
	- 수정자 주입
		- setter 로 의존성을 주입하는 방식
		- 선택 / 변경 가능성이 있는 의존관계에서 사용
		- @Component 설정한 클래스의 setter 메서드에 @Autowired 선언하면 자동으로 호출됨
			- 생성자와 수정자 둘다 쓰면 생성자가 먼저 호출됨
		- @Autowired(required = false) : required 옵션으로 자동으로 호출 안되게 할 수 있음
			- @Autowired의 기본 동작은 주입할 대상 없으면 오류가남
		
	- 필드 주입
		- 필드에 @Autowired 선언하여 바로 주입하는 방식
		- 외부에서 변경이 불가능해서 테스트하기 매우 힘들다
		- 안티패턴 : 사용하지 말자
			- 테스트 코드 정도에서만 사용하자
		
	- 일반 메서드 주입
		- 일반 메서드를 이용하여 의존성 주입
		- 한번에 여러 필드를 주입 받을 수 있따.
		- 거의 사용하지 않음
		
	- 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.
	
	
- 옵션 처리
	- 주입할 빈이 없어도 동작해야할 때가 있다.
	- @Autowired 만 사용하면 "required" 옵션이 true로 되어있다.
	

- 생성자 주입을 써야하는 이유
	- 대부분의 상황에서 생성자 주입을 권장
	- 대부분의 의존관계는 주입이 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
	- 테스트 코드 작성 시 컴파일 단계에서 수정자 주입에서 확인하지 못한 오류를 확인할 수 있다.
	- 생성자로 주입받는 필드에 final 사용 가능
		- 생성자를 잘못 구현했을 때 컴파일 단계에서 오류 확인 가능
	- 항상 생성자 주입을 사용하고 옵션이 필요한 경우 수정자 주입 사용하는것이 좋다.


- 롬복
	- start.spring.io 에서 프로젝트 만들때 선택도 가능
	- @RequiredArgsConstructor
		- final이 붙은 필드 값(필수값)을 가지고 생성자를 만들어 줌
	- @Getter, @Setter 등 다양한 기능 제공


- 조회 빈이 2개 이상 문제
	- @Autowired 는 type으로 조회한다.
	- 자동 의존 관계 주입 시 같은 타입 빈이 2개일 때 오류가 발생한다.
	- 이름만 다르고, 같은 타입 빈이 여러개 있으면 해결이 안된다.
	- 스프링 빈을 수동 등록해서 해결할 수 있지만, 자동 의존관계 주입으로도 해결하는 방법이 있다.

- 조회 대상 빈 2개 이상일 때 해결 방법
	- @Autowired 필드 명 매칭
	- @Qualifier -> @Qualifier 끼리 매칭 -> 빈 이름 매칭
	- @Primary 사용
	
	- @Autowired
		- @Autowired는 타입 매칭을 시도하고, 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
			- ex) 생성자에서 파라미터 명을 특정 빈 명으로 수정해서 매칭시킬 수 있다.
		
		- @Autowired 매칭 정리
			- 1. 타입매칭
			- 2. 타입 매칭의 결과가 2개 이상일 때 필드명, 파라미터 명으로 빈 이름 매칭
	
	- @Qualifier 사용
		- 추가 구분자를 붙여주는 방식
		- ex) 생성자 주입을 사용할 때, 빈 등록할때 @Qualifier로 명시하고, 생성자 주입 파라미터에 @Qualifier로 매칭한다.
		- @Qualifier("QualifierName") 으로 못 찾으면 "QualifierName" 이라는 이름의 스프링 빈을 추가로 찾는다.
		- @Qualifier 는 @Qualifier 를 찾는 용도로만 사용하는게 명확하고 좋다
	
	- @Primary
		- @Autowired 시에 여러 빈이 매칭되면 @Primary 붙어있는 클래스가 우선권을 가진다.
	
	
	- @Qualifier, @Primary 활용
		- 메인으로 사용하는 빈은 @Primary 로 사용하고, 서브로 사용하는 빈은 @Qualifier 로 명시적으로 사용하는 방법이 있다.
		- @Qualifier가 우선권이 높다. -> 수동으로 지정하는 방식이기 때문에.. 스프링은 자동보다는 수동이, 넓은 범위보다는 좁은 범위의 선택권이 우선순위가 높다.
	

- 어노테이션 직접 만들기
	- @Qualifier("mainDiscountPoilcy")
		- 해당 어노테이션을 사용할 경우, 값으로 문자를 넣기때문에 실수로 문자를 잘못 입력한 경우 컴파일 시점에서는 오류를 찾지 못한다.
		- @Qualifier("mainDiscountPoilcy") 기능을하는 @MainDiscountPolicy 를 만들수 있다.
	- 이렇게 어노테이션을 직접만들면 코드 추적하기도 쉽다.

	- 무분별하게 여러 애노테이션을 조합해서 만드는 건 피하자.


- 조회한 빈이 모두 필요할 때, List, Map
	- 타입이 인터페이스인 Map이나 List 를 파라미터로 받는 생성자를 만들면 해당 타입에 해당하는 빈들을 모두 Map에 주입받는다.
	
	```java
	private final Map<String, DiscountPolicy> policyMap;
	private final List<DiscountPolicy> policies;

	@Autowired
	public DiscountService(Map<String, DiscountPolicy> policyMap, List<DiscountPolicy> policies) {
		this.policyMap = policyMap;
		this.policies = policies;
	}
	```
	
	- ```Map<String, DiscountPolicy> policyMap``` 의 경우 key 값으로 스프링 빈의 이름이 들어간다.



- 자동, 수동의 올바른 실무 운영 기준
	
	- 편리한 자동 기능을 기본으로 사용하자
	
	- @Configuration 설정 정보를 만드는건 상당히 번거롭다 -> 관리할 대상이 많아질수록..
	
	- 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다.
	
	
	- 수동 빈 등록은 언제 사용하면 좋을까?
		- 애플리케이션은 크게 업무 로직과 기술지원 로직으로 나눌 수 있다.
			- 업무 로직 빈
				- 컨트롤러, 서비스, 리포지토리 등 비즈니스 요구사항을 구현하기 위한 빈
			- 기술 지원 빈
				- 기술적인 문제나 공통 관심사(AOP)를 처리하기 위해 사용되는 빈. 데이터베이스 연결이나 공통 로그 처리 등
		
		- 기술지원 로직은 영향도를 파악하기 어렵기때문에 수동 빈 등록을 사용하는 것이 좋다.
	
		- 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 바로 나타내게하는 것이 유지보수에 좋다.
	
		- 비즈니스 로직 중에 다형성을 적극 활용할 때..
	
	- 자동 등록을 사용하고 싶으면 관련 빈들만 따로 모아서 특정 패키지에 모아두는 것이 좋다.
