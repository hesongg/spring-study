### 스프링 핵심 원리 - 기본 

#### Reference) 
	* 스프링 핵심 원리 - 기본 (인프런 김영한님 강의 학습한 내용 정리)

#### 작성 코드
https://github.com/hesongg/inflearn-study


#### 빈 스코프

- 스코프 : 빈이 존재할 수 있는 범위

- 스프링의 다양한 스코프
	- 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
	- 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
		- 초기화 메서드는 호출하지만 종료 메서드는 사용 불가
	
- 웹 관련 스코프
	- request : 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
	- session : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
	- application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프
	

- 프로토타입 스코프
	- @Scope("prototype") 로 사용 -> @Scope의 기본 값은 "singleton" 이다.
	- 싱글톤 스코프 : 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환
	- 반면 프로토타입 스코프는 스프링 컨테이너에 조회하면 스프링 컨테이는 항상 새로운 인스턴스를 생성해서 반환한다.
	
	- 프로토타입 빈의 요청
		- 1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청
		- 2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다. (초기화 수행)
		- 3. 스프링 컨테이너는 생성한 프로토 타입 빈을 클라이언트에 반환한다.
		- 4. 이후에 스프링 컨테이너에 같은 요청이오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.

	- 핵심) 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 점
		- 클라이언트에게 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다.
		- 프로토타입 빈을 관리할 책임은 해당 빈을 받은 클라이언트에게 있다.
			- 종료 메서드에 대한 호출도 클라이언트가 직접 해야된다.
		- 그래서 @PreDestroy 같은 종료 메서드가 호출되지 않음.
		

- 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
	- 싱글톤 빈의 생성자로 프로토타입 빈을 주입받아 사용하는 경우
		- 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기때문에, 프로토타입 빈이 새로 생성되기는 하지만 싱글톤 빈과 함께 유지되는 것이 문제
		- 프로토타입 빈을 주입 시점에만 새로 생성하는 것이 아니라, 사용할 때 마다 새로 생성해서 사용하는 것을 원할 것이다.
		

- 의존관계를 외부에서 주입(DI)받는게 아니라, 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 탐색 이라고 한다.


- 빈을 찾아주는 기능
	- ```ObjectProvider```

		```java
		@Autowired
		private ObjectProvider<PrototypeBean> prototypeBeanProvider;
		```
		
		- ```ObjectProvider``` 선언 후, 
			```java
			PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
			```
			
			- 스프링 컨테이너에서 빈을 찾아서 반환해준다.
			
			- 직접 ApplicationContext에 요청하지 않아도 된다.
		
		- ```prototypeBeanProvider.getObject();``` 를 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인 가능
			- 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. ("DL")
		
		- 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
		
		- ```ObjectProvider```는 지금 딱 필요한 DL 정도의 기능만 제공한다.
		
		- ObjectProvider 대신 ObjectFactory 사용 가능
			- ObjectProvider 는 ObjectFactory를 상속받은 인터페이스로, 편의기능이 몇가지 추가되어있음
			- ```ObjectFactory``` : 기능이 단순, 별도의 라이브러리 필요없음, 스프링에 의존
			- ```Objectprovider``` : ObjectFactory 상속, 옵션, 스트림 처리 등 편의기능이 많고, 별도의 라이브러리 필요 없음, 스프링에 의존
		
	- JSR-330 Provider - ```java.inject.Provider``` 
		- gradle에 디펜던시 추가 필요함
		- ```provider.get()``` 을 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인 가능
		- ```get()``` 호출 시 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.
		- 자바 표준이고 기능이 단순하다.
		
	- ```ObjectProvider```, ```JSR303 Provider``` 등은 프로토타입 뿐만 아니라 DL이 필요한 경우 언제든지 사용 가능
	

- 프로토타입 빈을 사용하는 경우?
	- 사용할때마다 의존관계 주입이 완료된 새로운 객체가 필요한 경우
	- 그런데 싱글톤 빈으로 대부분의 문제가 해결됨


- 웹 스코프

	- 웹 스코프의 특징
		- 웹 환경에서만 동작
		- 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출됨
		
	- 웹 스코프 종류
		- request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
		- session : HTTP Session과 동일한 생명주기를 가지는 스코프
		- application : 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
		- websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프
	
	- 참고) 스프링 부트는 웹 라이브러리가 없으면 'AnnotationConfigApplicationContext' 를 기반으로 애플리케이션을 구동한다.
		웹 라이브러리가 추가되면 웹과 관련된 추가 설정과 환경들이 필요하므로 'AnnotationConfigServletWebServerApplicationContext' 를
		기반으로 애플리케이션을 구동한다.
		
	- @Scope("request") 로 설정한 빈은 http 요청마다 각각 구분되어 다른 HTTP 요청과 섞이지 않는다.
	
	- @Scopre(request") 로 빈 만들어서 테스트해보니..
		- 스프링 부트가 기동될 때 해당 빈을 사용하는 객체 생성자에서 @Autowired로 의존성 주입받게되면, 
			http 요청이 발생하지 않았으므로 에러가 발생하게된다.
		- 생성자 주입받지않고, ObjectProvider 를 이용하여서 필요한 시점에 꺼내어서 쓰는 방식을 사용으로 기동 시 오류 해결
	
	
	- 프록시 모드
		- 프록시 방식을 사용
		
		- 예시) 적용 대상이 클래스면 TARGET_CLASS / 인터페이스면 INTERFACES를 선택
			```java
			@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
			```
		- CGLIB 라이브러리로 내 클래스를 상속받은 가짜 프록시 클래스를 만들어서 주입해놓는다.
		
		- 스프링 컨테이너에 'myLogger' 라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록한다.
		
		- 의존관계 주입도 이 가짜 프록시 객체가 주입된다.
		
		- 가짜 프록시 객체는 요청이 왔을 때 내부에서 진짜 빈을 요청하는 위임 로직이 들어잇다.
		
		- 가짜 프록시 객체는 원본 클래스를 상속받아서 만들어져있다. (다형성)
		
	
	- Provider를 이용하던, 프록시를 이용하던 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연 처리 한다는 점이다.
	
	- 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 주의해서 사용해야한다.
	
	- 이런 특별한 scope는 최소화해서 꼭 필요한 곳에서만 사용해야한다.
