### 스프링 핵심 원리 - 고급편

#### Reference) 
	* 스프링 핵심 원리 - 고급편 (인프런 김영한님 강의 학습한 내용 정리)

#### 작성 코드
- https://github.com/hesongg/Spring-Advanced
	
<br>


### 쓰레드 로컬 - ThreadLocal

<br>

#### 필드 동기화 - 개발

- ```TraceId``` 를 파라미터로 넘기지 않고 이 문제를 해결할 수 있는 방법은 없을까?

- 향후 다양한 구현제로 변경할 수 있도록 ```LogTrace``` 인터페이스를 먼저 만들고, 구현해보자.

- 파라미터를 넘기지 않고 TraceId 를 동기화 할 수 있는 ```FieldLogTrace``` 구현체를 생성

<br>

- ```FieldLogTrace``` 는 기존에 만들었던 ```HelloTraceV2``` 와 거의 같은 기능을 한다.
	- ```TraceId``` 를 동기화 하는 부분만 파라미터를 사용하는 것에서 ```TraceId traceIdHolder``` 필드를 사용하도록 변경되었다.
	
	- 이제 직전 로그의 TraceId 는 파라미터로 전달되는 것이 아니라 ```FieldLogTrace``` 의 필드인 ```traceIdHolder``` 에 저장된다.

- 여기서 중요한 부분은 로그를 시작할 때 호출하는 ```syncTraceId()``` 와 로그를 종료할 때 호출하는 ```releaseTraceId()``` 이다.

- ```syncTraceId()```
	- ```TraceId``` 를 새로 만들거나 앞선 로그의 ```TraceId``` 를 참고해서 동기화하고, ```level``` 도 증가한다.
	- 최초 호출이면 ```TraceId``` 를 새로 만든다.
	- 직전 로그가 있으면 해당 로그의 ```TraceId``` 를 참고해서 동기화하고, ```level``` 도 하나 증가한다.
	- 결과를 ```traceIdHolder``` 에 보관한다.

- ```releaseTraceId()```
	- 메서드를 추가로 호출할 때는 ```level``` 이 하나 증가해야 하지만, 메서드 호출이 끝나면 ```level``` 이 하나 감소해야 한다.
	- ```releaseTraceId()``` 는 ```level``` 을 하나 감소한다.
	- 만약 최초 호출( ```level==0``` )이면 내부에서 관리하는 ```traceId``` 를 제거한다.

- 이제 불필요하게 ```TraceId``` 를 파라미터로 전달하지 않아도 되고, 애플리케이션의 메서드 파라미터도 변경하지 않아도 된다.

<br>

#### 필드 동기화 - 적용

- ```traceIdHolder``` 필드를 사용한 덕분에 파라미터 추가 없는 깔끔한 로그 추적기를 완성했다. 
	- 이제 실제 서비스에 배포한다고 가정해보자.

<br>

#### 필드 동기화 - 동시성 문제

- 잘 만든 로그 추적기를 실제 서비스에 배포했다 가정해보자.
	- 테스트 할 때는 문제가 없는 것 처럼 보인다. 사실 직전에 만든 ```FieldLogTrace``` 는 심각한 동시성 문제를 가지고 있다.

- 동시성 문제를 확인하려면 다음과 같이 동시에 여러번 호출해보면 된다.
	- 동시성 문제 확인
		- 다음 로직을 1초 안에 2번 실행해보자.

<br>

- ```FieldLogTrace``` 는 싱글톤으로 등록된 스프링 빈이다. 
	- 이 객체의 인스턴스가 애플리케이션에 딱 1개 존재한다는 뜻이다. 
	- 이렇게 하나만 있는 인스턴스의 ```FieldLogTrace.traceIdHolder``` 필드를 여러 쓰레드가 동시에 접근하기 때문에 문제가 발생한다.

<br>

#### 동시성 문제 - 예제 코드

- 동시성 문제가 어떻게 발생하는지 단순화해서 알아보자.
	- 커밋한 ```FieldService``` 코드 참고

<br>

- 동시성 문제
	- 결과적으로 ```Thread-A``` 입장에서는 저장한 데이터와 조회한 데이터가 다른 문제가 발생한다. 
	
	- 이처럼 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제를 동시성 문제라 한다. 
	
	- 이런 동시성 문제는 여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하기 때문에 트래픽이 적은 상황에서는 확률상 잘 나타나지 않고, 
		트래픽이 점점 많아질 수 록 자주 발생한다.
	
	- 특히 스프링 빈 처럼 싱글톤 객체의 필드를 변경하며 사용할 때 이러한 동시성 문제를 조심해야 한다.

- 참고
	- 이런 동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당된다.
	
	- 동시성 문제가 발생하는 곳은 같은 인스턴스의 필드(주로 싱글톤에서 자주 발생), 
		또는 static 같은 공용 필드에 접근할 때 발생한다.
		
	- 동시성 문제는 값을 읽기만 하면 발생하지 않는다. 어디선가 값을 변경하기 때문에 발생한다.

<br>

#### ThreadLocal - 소개

- 쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말한다

- 일반적인 변수 필드
	- 여러 쓰레드가 같은 인스턴스의 필드에 접근하면 처음 쓰레드가 보관한 데이터가 사라질 수 있다.

- 쓰레드 로컬
	- 쓰레드 로컬을 사용하면 각 쓰레드마다 별도의 내부 저장소를 제공한다. 
	- 따라서 같은 인스턴스의 쓰레드 로컬 필드에 접근해도 문제 없다.

- 자바는 언어차원에서 쓰레드 로컬을 지원하기 위한 ```java.lang.ThreadLocal``` 클래스를 제공한다.

<br>

#### ThreadLocal - 예제 코드

- 기존에 있던 ```FieldService``` 와 거의 같은 코드인데, ```nameStore``` 필드가 
	일반 ```String``` 타입에서 ```ThreadLocal``` 을 사용하도록 변경되었다

- ```ThreadLocal``` 사용법
	- 값 저장: ```ThreadLocal.set(xxx)```
	- 값 조회: ```ThreadLocal.get()```
	- 값 제거: ```ThreadLocal.remove()```

- 주의
	- 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 ```ThreadLocal.remove()``` 를 호출해서 
		쓰레드 로컬에 저장된 값을 제거해주어야 한다. 제거하는 구체적인 예제는 조금 뒤에 설명하겠다.

- 쓰레드 로컬 덕분에 쓰레드 마다 각각 별도의 데이터 저장소를 가지게 되었다. 결과적으로 동시성 문제도 해결되었다.

<br>

#### 쓰레드 로컬 동기화 - 개발

- ```FieldLogTrace``` 에서 발생했던 동시성 문제를 ```ThreadLocal``` 로 해결해보자.
	- ```TraceId traceIdHolder``` 필드를 쓰레드 로컬을 사용하도록 ```ThreadLocal<TraceId> traceIdHolder``` 로 변경하면 된다.

- 필드 대신에 쓰레드 로컬을 사용해서 데이터를 동기화하는 ```ThreadLocalLogTrace``` 를 새로 만듦

- ```ThreadLocal.remove()```
	- 쓰레드 로컬을 모두 사용하고 나면 꼭 ```ThreadLocal.remove()``` 를 호출해서 쓰레드 로컬에 저장된 값을 제거해주어야 한다. 

	- 여기서는 ```releaseTraceId()``` 를 통해 ```level``` 이 점점 낮아져서 ```2 -> 1 -> 0```이 되면 
		로그를 처음 호출한 부분으로 돌아온 것이다. 
		
		- 따라서 이 경우 연관된 로그 출력이 끝난 것이다. 
		
		- 이제 더 이상 TraceId 값을 추적하지 않아도 된다. 
		
		- 그래서 ```traceId.isFirstLevel() ( level==0 )```인 경우 ```ThreadLocal.remove()``` 를 호출해서 쓰레드 로컬에 저장된 값을 제거해준다.

<br>

#### 쓰레드 로컬 동기화 - 적용

- ```LogTraceConfig``` - 수정
	- 동시성 문제가 있는 ```FieldLogTrace``` 대신에 문제를 해결한 ```ThreadLocalLogTrace``` 를 스프링 빈으로 등록

<br>

#### 쓰레드 로컬 - 주의사항

- 쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

- 문제가 생기는 케이스의 예
	- 1. 사용자 A 에 대한 HTTP 요청에 대해서 WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
	
	- 2. ```thread-A```라는 쓰레드가 할당된다.
	
	- 3. ```thread-A```는 사용자 A의 데이터를 쓰레드 로컬에 저장한다.
	
	- 4. 쓰레드 로컬의 ```thread-A``` 전용 보관소에 사용자 A의 데이터를 보관한다.
	
	- 5. 사용자 A의 HTTP 응답이 끝나고, WAS는 사용이 끝난 ```thread-A``` 를 쓰레드 풀에 반환한다. 
		- 쓰레드를 생성하는 비용은 비싸기 때문에 쓰레드를 제거하지 않고, 보통 쓰레드 풀을 통해서 쓰레드를 재사용한다.
	
	- 6. ```thread-A``` 는 쓰레드풀에 아직 살아있다. 
		- 따라서 쓰레드 로컬의 thread-A 전용 보관소에 사용자A 데이터도 함께 살아있게 된다.

	- 7. 사용자B가 조회를 위한 새로운 HTTP 요청을 한다.
	
	- 8. WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
	
	- 9. 쓰레드 ```thread-A``` 가 할당되었다. (물론 다른 쓰레드가 할당될 수 도 있다.)
	
	- 10. 이번에는 조회하는 요청이다. ```thread-A``` 는 쓰레드 로컬에서 데이터를 조회한다.
	
	- 11. 쓰레드 로컬은 ```thread-A``` 전용 보관소에 있는 사용자A 값을 반환한다.
	
	- 12. 결과적으로 사용자A 값이 반환된다.
	
	- 13. 사용자B는 사용자A의 정보를 조회하게 된다.
	
<br>

- 결과적으로 사용자B는 사용자A의 데이터를 확인하게 되는 심각한 문제가 발생하게 된다.
	- 이런 문제를 예방하려면 사용자A의 요청이 끝날 때 쓰레드 로컬의 값을 ```ThreadLocal.remove()``` 를 통해서 꼭 제거해야 한다.
	- 쓰레드 로컬을 사용할 때는 이 부분을 꼭! 기억하자
